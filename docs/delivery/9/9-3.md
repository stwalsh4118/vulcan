# [9-3] Engine Dual-Write to LogBroker & SQLite

[Back to task list](./tasks.md)

## Description

Modify the engine's `LogWriter` callback to dual-write: publish to LogBroker (for real-time SSE, existing behavior) AND persist to SQLite via `Store.InsertLogLine`. Maintain a per-workload sequence counter to ensure correct ordering of persisted log lines.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-19 07:13:41 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-19 07:26:16 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-19 07:28:32 | Status Change | InProgress | Review | Implementation complete, internal AI review passed | AI_Agent |
| 2026-02-19 07:57:42 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. The `Engine` must have access to the `Store` (it already does — injected via `NewEngine`).
2. Modify the `LogWriter` callback in `engine.go`'s `execute()` method to:
   - Maintain a local sequence counter (int, starting at 0, incremented per line).
   - Call `e.store.InsertLogLine(ctx, w.ID, seq, line)` for each log line.
   - Continue to call `e.broker.Publish(w.ID, line)` (existing behavior unchanged).
3. Log persistence errors should be logged (via `e.logger`) but must NOT block execution or SSE streaming. The LogBroker publish must always proceed.
4. The sequence counter is local to the goroutine executing the workload — no concurrency concerns.

## Implementation Plan

1. In `engine.go`'s `execute()` method, add a `seq` counter variable before the `LogWriter` closure.
2. Update the `LogWriter` closure to:
   ```go
   LogWriter: func(line string) {
       if err := e.store.InsertLogLine(ctx, w.ID, seq, line); err != nil {
           e.logger.Error("failed to persist log line", "workload_id", w.ID, "seq", seq, "error", err)
       }
       seq++
       e.broker.Publish(w.ID, line)
   },
   ```
3. Verify that the `ctx` used is the workload's execution context (already available in scope).
4. Write a unit test verifying that after workload execution, log lines exist in the store.

## Test Plan

### Objectives
Verify that the engine persists log lines to SQLite during execution while maintaining real-time SSE streaming.

### Key Scenarios
1. **Dual-write works** — after executing a workload that produces log output, verify lines are persisted to the store with correct sequence numbers.
2. **SSE streaming unaffected** — LogBroker publish still works (subscribe and receive lines).
3. **Store failure is non-blocking** — if InsertLogLine returns an error, execution continues and LogBroker still receives the line.

### Success Criteria
- Log lines appear in the store after workload execution.
- Real-time SSE streaming behavior is unchanged.
- `go build ./...` and all existing tests pass.

## Verification

- `go build ./...` passes.
- `go vet ./...` clean.
- `go test -race ./...` — all tests pass, no race conditions.
- New tests: TestDualWriteLogPersistence (verifies lines persisted with correct seq), TestDualWriteSSEUnaffected (verifies SSE broker + persistence both work).
- AI review notes: seq is per-goroutine (no race); persistence errors are non-blocking per spec.

## Files Modified

- `api/internal/engine/engine.go` — Modified LogWriter callback to dual-write: InsertLogLine + Publish.
- `api/internal/engine/engine_test.go` — Added loggingBackend mock, TestDualWriteLogPersistence, TestDualWriteSSEUnaffected.
