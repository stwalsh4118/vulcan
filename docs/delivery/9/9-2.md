# [9-2] SQLite Log Persistence Implementation

[Back to task list](./tasks.md)

## Description

Add the `log_lines` table to the SQLite schema and implement the `InsertLogLine` and `GetLogLines` methods on `SQLiteStore`. This provides the durable storage layer that the engine (task 9-3) and API (task 9-4) will use.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-19 07:13:41 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-19 07:23:00 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-19 07:26:16 | Status Change | InProgress | Review | Implementation complete, internal AI review passed | AI_Agent |
| 2026-02-19 07:57:42 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. Add a `log_lines` table migration to the SQLiteStore initialization:
   ```sql
   CREATE TABLE IF NOT EXISTS log_lines (
       id          INTEGER PRIMARY KEY AUTOINCREMENT,
       workload_id TEXT NOT NULL REFERENCES workloads(id),
       seq         INTEGER NOT NULL,
       line        TEXT NOT NULL,
       created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
   );
   CREATE INDEX IF NOT EXISTS idx_log_lines_workload ON log_lines(workload_id, seq);
   ```
2. Implement `InsertLogLine(ctx, workloadID, seq, line) error` — single row insert.
3. Implement `GetLogLines(ctx, workloadID) ([]model.LogLine, error)` — select all rows for a workload, ordered by `seq ASC`.
4. Both methods must use parameterised queries (no SQL injection).

## Implementation Plan

1. Add the `CREATE TABLE` and `CREATE INDEX` statements to the migration block in `SQLiteStore` initialization (`api/internal/store/sqlite.go`).
2. Replace the stub `InsertLogLine` with a real `INSERT INTO log_lines` parameterised query.
3. Replace the stub `GetLogLines` with a `SELECT ... FROM log_lines WHERE workload_id = ? ORDER BY seq ASC` query, scanning into `[]model.LogLine`.
4. Write unit tests in `api/internal/store/sqlite_test.go` covering:
   - Insert and retrieve log lines for a workload.
   - Ordering by sequence number.
   - Empty result for workload with no log lines.
   - Multiple workloads don't cross-contaminate.

## Test Plan

### Objectives
Verify the SQLite log persistence layer correctly stores and retrieves log lines.

### Key Scenarios
1. **Insert single log line** — insert one line, retrieve it, verify all fields.
2. **Insert multiple lines** — insert N lines with sequential seq values, verify ordering.
3. **Empty workload** — `GetLogLines` for a workload with no logs returns empty slice, no error.
4. **Isolation between workloads** — lines for workload A do not appear in workload B's results.

### Success Criteria
- All unit tests pass.
- `go build ./...` succeeds.

## Verification

- `go build ./...` passes.
- `go vet ./...` clean.
- `go test -race ./...` — all tests pass, no race conditions.
- 4 new unit tests: TestInsertAndGetLogLines, TestGetLogLinesOrdering, TestGetLogLinesEmpty, TestGetLogLinesIsolation.

## Files Modified

- `api/internal/store/sqlite.go` — Added `log_lines` table/index migration; replaced stubs with real `InsertLogLine`/`GetLogLines`.
- `api/internal/store/sqlite_test.go` — Added 4 unit tests for log line persistence.
