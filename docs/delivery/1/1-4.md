# [1-4] SQLite Persistence Layer

[Back to task list](./tasks.md)

## Description

Implement the SQLite-backed store for workloads: database connection, schema migration (CREATE TABLE), and full CRUD operations (Create, GetByID, List with pagination, UpdateStatus).

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 11:12:42 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-18 11:27:32 | Status Change | Proposed | Agreed | User requested PBI implementation | AI_Agent |
| 2026-02-18 11:27:32 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2026-02-18 11:31:10 | Status Change | InProgress | Review | Implementation complete, internal AI review passed | AI_Agent |
| 2026-02-18 11:58:00 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. `internal/store/store.go` — `Store` interface defining workload operations:
   - `CreateWorkload(ctx, *Workload) error`
   - `GetWorkload(ctx, id) (*Workload, error)`
   - `ListWorkloads(ctx, limit, offset) ([]*Workload, int, error)` — returns items + total count
   - `UpdateWorkloadStatus(ctx, id, status) error`
2. `internal/store/sqlite.go` — SQLite implementation:
   - `NewSQLiteStore(dbPath) (*SQLiteStore, error)` — opens DB, runs migrations.
   - `Close() error`.
   - Workloads table per PRD schema (see Data Model in PRD).
3. Migration creates the `workloads` table with all columns from the PRD data model.
4. Use `database/sql` with `modernc.org/sqlite` driver (pure Go, no CGO).
5. List supports pagination via `LIMIT` and `OFFSET`, orders by `created_at DESC`.
6. `UpdateWorkloadStatus` sets the status and, if status is `killed`, sets `finished_at`.

## Implementation Plan

1. Create `internal/store/store.go` with the `Store` interface.
2. Create `internal/store/sqlite.go` implementing the interface.
3. In `NewSQLiteStore`, open DB with `sql.Open("sqlite", dbPath)`, enable WAL mode, run CREATE TABLE IF NOT EXISTS.
4. Implement `CreateWorkload` — INSERT with all fields from the Workload struct.
5. Implement `GetWorkload` — SELECT by ID, scan into Workload struct.
6. Implement `ListWorkloads` — SELECT with LIMIT/OFFSET + COUNT query for total.
7. Implement `UpdateWorkloadStatus` — UPDATE status (and finished_at for terminal states).
8. Run `go get modernc.org/sqlite`.

**External Packages**: This task requires research and a guide document for: `modernc.org/sqlite`

## Test Plan

### Objectives
Verify the SQLite store correctly persists, retrieves, lists, and updates workloads.

### Test Scope
- Unit tests against an in-memory SQLite database (`:memory:` or temp file).

### Key Scenarios
1. **Create and retrieve**: Create a workload, retrieve by ID, verify all fields match.
2. **List with pagination**: Insert multiple workloads, verify limit/offset work, verify total count.
3. **List ordering**: Verify results ordered by created_at DESC.
4. **Update status**: Update a workload status, verify it persists. Verify `finished_at` set for `killed`.
5. **Get non-existent**: GetWorkload with unknown ID returns appropriate error.
6. **Migration idempotency**: Opening store twice on same DB doesn't error (IF NOT EXISTS).

### Success Criteria
- All CRUD operations work against in-memory SQLite.
- Pagination returns correct subsets and total counts.
- Status updates are persisted.

## Verification

- `go build ./cmd/vulcan` succeeds.
- `go vet ./...` passes.
- All 9 store tests pass: CRUD, pagination, ordering, not-found, migration idempotency.

## Files Modified

- `api/internal/store/store.go` — Store interface definition
- `api/internal/store/sqlite.go` — SQLite implementation with CRUD
- `api/internal/store/sqlite_test.go` — Comprehensive unit tests
- `api/go.mod` / `api/go.sum` — Added modernc.org/sqlite dependency
- `docs/delivery/1/1-4-sqlite-guide.md` — External package research guide
