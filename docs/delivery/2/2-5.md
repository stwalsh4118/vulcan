# [2-5] Async Execution Engine

[Back to task list](./tasks.md)

## Description

Build the core execution engine that runs workloads asynchronously in goroutines with timeout enforcement. Add the `POST /v1/workloads/async` endpoint that returns 202 immediately with the workload ID. The engine transitions workloads through the state machine (pending→running→completed/failed), enforces timeout via context deadlines, and updates the store with results in real time.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 13:14:02 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-18 13:53:31 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-18 14:06:01 | Status Change | InProgress | Review | Implementation complete, internal AI review passed | AI_Agent |
| 2026-02-19 04:43:58 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. Create `internal/engine/engine.go` with an `Engine` struct that orchestrates execution.
2. `Submit(ctx context.Context, workload *model.Workload) error`:
   - Resolve backend via registry
   - Store workload as pending
   - Launch goroutine to execute
3. Goroutine execution flow:
   - Update status to running (via store)
   - Set started_at timestamp
   - Create context with timeout from workload's timeout_s (default 30s if not set)
   - Call `backend.Execute(ctx, spec)`
   - On success: update to completed with output, exit code, duration
   - On context deadline exceeded: update to failed with timeout error
   - On other error: update to failed with error message
4. Add `POST /v1/workloads/async` endpoint:
   - Accept same request body as `POST /v1/workloads`
   - Return `202 Accepted` with workload object (status: pending)
   - Execution happens in background
5. `GET /v1/workloads/:id` must reflect real-time status (already works via store reads).
6. Default timeout: 30 seconds if not specified in request.

## Implementation Plan

1. Create `api/internal/engine/` directory.
2. Create `api/internal/engine/doc.go` with package documentation.
3. Create `api/internal/engine/engine.go`:
   - `Engine` struct: store, registry, logger
   - `NewEngine(store, registry, logger) *Engine`
   - `Submit()` method
   - Private `execute()` method for goroutine
   - Default timeout constant
4. Create `api/internal/api/async.go`:
   - `handleAsyncWorkload` handler
   - Parse request, create workload model, call engine.Submit
   - Return 202 with workload
5. Update `api/internal/api/server.go`:
   - Accept `*engine.Engine` as a dependency
   - Add `POST /v1/workloads/async` route
6. Update `api/cmd/vulcan/main.go` to create and pass engine.
7. Write unit tests with a mock backend.

## Test Plan

### Objectives
Verify async execution lifecycle, timeout enforcement, and real-time status updates.

### Mocking Strategy
- Create a mock backend implementing `Backend` interface (configurable delay, output, errors).
- Use in-memory SQLite store.

### Key Scenarios
1. **Happy path**: Submit workload → status transitions pending→running→completed, output stored, duration recorded.
2. **Backend error**: Mock backend returns error → status transitions to failed, error message stored.
3. **Timeout enforcement**: Submit with timeout_s=1, mock backend sleeps 5s → status is failed, error mentions timeout.
4. **Default timeout**: Submit without timeout_s → 30s default applied.
5. **API endpoint**: POST /v1/workloads/async returns 202, workload has pending status and valid ID.
6. **Concurrent execution**: Submit multiple workloads, all execute concurrently.

### Success Criteria
- All status transitions recorded correctly in store.
- Timed-out workloads are marked failed with descriptive error.
- 202 response returned immediately (before execution completes).

## Verification

- All tests pass with `-race -count=1` (0 failures)
- `go vet ./...` clean
- `gofmt` clean
- AI review verdict: **pass** (0 critical, 0 high, 0 medium after fixes, 3 low deferred)
- Deferred low findings: isolation default divergence (intentional — sync path doesn't execute), store call timeouts (mitigated by SQLite busy_timeout), Wait() test (trivial wrapper)

## Files Modified

- `api/internal/engine/doc.go` (new) — package documentation
- `api/internal/engine/engine.go` (new) — Engine struct, Submit, execute, finishFailed, Wait
- `api/internal/engine/engine_test.go` (new) — 6 test scenarios
- `api/internal/api/async.go` (new) — handleAsyncWorkload handler
- `api/internal/api/server.go` (modified) — added registry, engine deps, POST /v1/workloads/async route, GET /v1/backends route
- `api/internal/api/server_test.go` (modified) — updated newTestServer with registry and engine
- `api/internal/model/workload.go` (modified) — added pending→failed to validTransitions
- `api/internal/model/model_test.go` (modified) — updated transition test cases
- `api/internal/store/sqlite_test.go` (modified) — removed pending→failed from invalid transitions
- `api/cmd/vulcan/main.go` (modified) — creates registry and engine, passes to NewServer
