# [2-5] Async Execution Engine

[Back to task list](./tasks.md)

## Description

Build the core execution engine that runs workloads asynchronously in goroutines with timeout enforcement. Add the `POST /v1/workloads/async` endpoint that returns 202 immediately with the workload ID. The engine transitions workloads through the state machine (pending→running→completed/failed), enforces timeout via context deadlines, and updates the store with results in real time.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 13:14:02 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

1. Create `internal/engine/engine.go` with an `Engine` struct that orchestrates execution.
2. `Submit(ctx context.Context, workload *model.Workload) error`:
   - Resolve backend via registry
   - Store workload as pending
   - Launch goroutine to execute
3. Goroutine execution flow:
   - Update status to running (via store)
   - Set started_at timestamp
   - Create context with timeout from workload's timeout_s (default 30s if not set)
   - Call `backend.Execute(ctx, spec)`
   - On success: update to completed with output, exit code, duration
   - On context deadline exceeded: update to failed with timeout error
   - On other error: update to failed with error message
4. Add `POST /v1/workloads/async` endpoint:
   - Accept same request body as `POST /v1/workloads`
   - Return `202 Accepted` with workload object (status: pending)
   - Execution happens in background
5. `GET /v1/workloads/:id` must reflect real-time status (already works via store reads).
6. Default timeout: 30 seconds if not specified in request.

## Implementation Plan

1. Create `api/internal/engine/` directory.
2. Create `api/internal/engine/doc.go` with package documentation.
3. Create `api/internal/engine/engine.go`:
   - `Engine` struct: store, registry, logger
   - `NewEngine(store, registry, logger) *Engine`
   - `Submit()` method
   - Private `execute()` method for goroutine
   - Default timeout constant
4. Create `api/internal/api/async.go`:
   - `handleAsyncWorkload` handler
   - Parse request, create workload model, call engine.Submit
   - Return 202 with workload
5. Update `api/internal/api/server.go`:
   - Accept `*engine.Engine` as a dependency
   - Add `POST /v1/workloads/async` route
6. Update `api/cmd/vulcan/main.go` to create and pass engine.
7. Write unit tests with a mock backend.

## Test Plan

### Objectives
Verify async execution lifecycle, timeout enforcement, and real-time status updates.

### Mocking Strategy
- Create a mock backend implementing `Backend` interface (configurable delay, output, errors).
- Use in-memory SQLite store.

### Key Scenarios
1. **Happy path**: Submit workload → status transitions pending→running→completed, output stored, duration recorded.
2. **Backend error**: Mock backend returns error → status transitions to failed, error message stored.
3. **Timeout enforcement**: Submit with timeout_s=1, mock backend sleeps 5s → status is failed, error mentions timeout.
4. **Default timeout**: Submit without timeout_s → 30s default applied.
5. **API endpoint**: POST /v1/workloads/async returns 202, workload has pending status and valid ID.
6. **Concurrent execution**: Submit multiple workloads, all execute concurrently.

### Success Criteria
- All status transitions recorded correctly in store.
- Timed-out workloads are marked failed with descriptive error.
- 202 response returned immediately (before execution completes).

## Verification

_To be completed during implementation._

## Files Modified

_To be completed during implementation._
