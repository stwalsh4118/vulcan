# [2-4] Backend Registry & Auto-Routing

[Back to task list](./tasks.md)

## Description

Build a backend registry that holds registered backends, resolves `auto` isolation mode to the appropriate backend based on runtime/format, validates that a requested isolation backend is available, and exposes registered backends via `GET /v1/backends`.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 13:14:02 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-18 13:48:20 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-18 13:53:09 | Status Change | InProgress | Review | Implementation complete, internal AI review passed | AI_Agent |
| 2026-02-19 04:43:58 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. Create `internal/backend/registry.go` with a `Registry` struct.
2. `Register(name string, b Backend)` — register a backend by name.
3. `Resolve(isolation, runtime string) (Backend, error)` — resolve which backend to use:
   - If isolation is `auto`: JS/TS runtime → isolate, OCI runtime → gVisor, archive/other → microVM.
   - If isolation is explicit: look up by name, return error if not registered.
4. `List() []BackendInfo` — return all registered backends with their capabilities.
5. Define `BackendInfo` struct: name + capabilities.
6. Add `GET /v1/backends` endpoint to the API server returning the list of registered backends and capabilities.
7. Wire the registry into the API server (accept it as a dependency).

## Implementation Plan

1. Create `api/internal/backend/registry.go`:
   - `Registry` struct with `map[string]Backend`
   - `NewRegistry() *Registry`
   - `Register()`, `Resolve()`, `List()` methods
   - Auto-routing map: runtime → default isolation
2. Create `api/internal/api/backends.go`:
   - `handleListBackends` handler returning registered backends
3. Update `api/internal/api/server.go`:
   - Accept `*backend.Registry` as a dependency in `NewServer`
   - Add `GET /v1/backends` route
4. Update `api/cmd/vulcan/main.go` to create and pass registry.
5. Write unit tests for registry and endpoint.

## Test Plan

- Test `Register` and `List`: register multiple backends, verify all appear in list with correct capabilities.
- Test `Resolve` with explicit isolation: registered backend returns successfully; unregistered returns error.
- Test `Resolve` with `auto` isolation:
  - runtime=node → resolves to isolate
  - runtime=oci → resolves to gvisor
  - runtime=go → resolves to microvm
- Test `Resolve` auto when target backend not registered returns error.
- Test `GET /v1/backends` endpoint returns 200 with correct JSON structure.

## Verification

- All tests pass with `-race` flag.
- Auto-routing correctly maps all 5 runtimes.
- Registry operations are thread-safe with RWMutex.
- GET /v1/backends returns sorted, stable JSON response.

## Files Modified

- `api/internal/backend/registry.go` — NEW: Registry struct with Register, Resolve, List; autoRouting map; BackendInfo type
- `api/internal/backend/registry_test.go` — NEW: 6 tests covering registration, resolution, auto-routing
- `api/internal/api/backends.go` — NEW: handleListBackends endpoint handler
- `api/internal/api/server.go` — MODIFIED: added registry field, updated NewServer signature, added GET /v1/backends route
- `api/internal/api/server_test.go` — MODIFIED: updated newTestServer to pass registry
- `api/internal/api/workload_test.go` — MODIFIED: added backends endpoint tests
- `api/cmd/vulcan/main.go` — MODIFIED: creates and passes Registry to NewServer
